[{"type":"yamlHeader","data":{"author":"v-josjones","ms.author":"v-josjones","title":"Animation Documentation - Animation Controllers","ms.prod":"gaming"}},{"type":"heading","data":"Animation Documentation - Animation Controllers"},{"type":"other","data":"Animation controllers decide which animations to play when.  Each controller contains a list of states that play one or more animations, each of which can be blended by a Molang expression if so desired.  Controller files are stored as JSON in the animation_controllers folder"},{"type":"heading","data":"Animation Controller Format"},{"type":"code","data":{"format_version":"1.17.30","animation_controllers":{"controller.animation.sheep.move":{"states":{"default":{"animations":[{"walk":"query.modified_move_speed"}],"transitions":[{"grazing":"query.is_grazing"}]},"grazing":{"animations":["grazing"],"transitions":[{"default":"query.all_animations_finished"}]}}}}},"language":"JSON"},{"type":"heading","data":"States"},{"type":"other","data":"A state defines a group of animations to process (each of which can have it's own blend value). Each state has an optional variables section, listing any number of variables that referenced animations can use.  Each state also has one or more animations, using the name given in the entity's definition json."},{"type":"heading","data":"State Blending"},{"type":"other","data":"If you would like there to be a cross-fade between states when transitioning, simply set \"blend_transition\" to the time you would like the system to take in blending between the two states.  This is done as a simple lerp between the two states over the time specified."},{"type":"heading","data":"Example of State Blending"},{"type":"code","data":{"controller.animation.tiger.move":{"states":{"default":{"animations":["base_pose","walk"],"transitions":[{"angry":"query.is_angry"}],"blend_transition":0.2},"angry":{"animations":["roar","extend_claws"],"transitions":[{"default":"query.any_animation_finished"}]}}}},"language":"JSON"},{"type":"heading","data":"State Transitions"},{"type":"other","data":"A state can specify any number of transition scripts, listed in order.  Each transition has a target state to switch to, and a script for whether it should switch or not.  For each transition in order, evaluate the script, and if it returns non-zero, switch to the specified state immediately.  NOTE: Only one transition will be processed per frame."},{"type":"code","data":{"<controller_name>":{"states":{"<state_name>":{"transitions":[{},{}]}}}},"language":"JSON"},{"type":"heading","data":"Example of State Transitions"},{"type":"code","data":{"controller.animation.tiger.move":{"states":{"default":{"animations":["base_pose","walk"],"transitions":[{"angry":"query.is_angry"},{"tired":"variable.is_tired"}]},"angry":{"animations":["roar","extend_claws"],"transitions":[{"default":"query.any_animation_finished"}]},"tired":{"animations":["yawn","stretch"],"transitions":[{"default":"query.all_animation_finished"}]}}}},"language":"JSON"},{"type":"heading","data":"State Variables"},{"type":"other","data":"Variables are either set by the game or by a user defined script that can be found in the entity definition json found in definitions/entity/<entity_name>.json. Variables have their value set by a Molang Expression.  They can also have their value remapped via a linearly-interpolated curve."},{"type":"heading","data":"Example"},{"type":"other","data":"This defines a controller with a single state.  It will create a variable `variable.ground_speed_curve` that lives on the entity only while processing the animation controller for that frame.  It will take the value of `query.ground_speed`, then remap it to between 0.2 and 0.7 based on the value of `query.ground_speed` going from 0.0 to 1.0It will play one animation walk that will blend from 0.0 to 1.0 as the ground speed increases from stopped to 2.3 m/s.  The remap curve can have any number of entries.  The animation controller will then play the entity-referenced `wiggle_nose` animations, followed by the `walk` animation, scaling the latter by the value of `variable.ground_speed_curve`."},{"type":"code","data":{"format_version":"1.17.30","animation_controllers":{"controller.animation.sheep.move":{"states":{"default":{"variables":{"ground_speed_curve":{"input":"query.ground_speed","remap_curve":{"0.0":0.2,"1.0":0.7}}},"animations":["wiggle_nose",{"walk":"variable.ground_speed_curve"}]}}}}},"language":"JSON"},{"type":"heading","data":"User-Defined Script Example"},{"type":"other","data":"This script will set foo to the result of the sine of query.life_time to later be used in the animation or animation controller."},{"type":"alert","data":"NOTE"},{"type":"quote","data":"\"pre_animation\" tells the script to figure out the values of those variables once a frame, before animation occurs, so that the animation can use those values in their own formulas. If a variable didn't exist, it will create a new variable and its default value will be 0.0"},{"type":"other","data":"In definitions\\entity\\tiger.json:"},{"type":"code","data":{"custom:tiger":{"scripts":{"pre_animation":{}}}},"language":"JSON"},{"type":"other","data":"In this example that because foo is equal to a sin wave, that its values will range from -1 to 1.  This means that you will have a period from 0 to -1 to 0 where only \"base_pose\" will play and then an equal amount of time where Walk will play on top of base_pose as foo goes from 0 to 1 back to 0.  Base_pose will have a blend value of 1.0."},{"type":"code","data":{"controller.animation.tiger.move":{"states":{"default":{"animations":["base_pose",{"walk":"variable.foo > 0.0"}]}}}},"language":"JSON"},{"type":"heading","data":"State Transitions"},{"type":"other","data":"Each transition has a target state to switch to, and a script for whether it should switch or not.  For each transition in order, evaluate the script, and if it returns non-zero, switch to the specified state immediately.  NOTE: Only one transition will be processed per frame."},{"type":"code","data":{"<controller_name>":{"states":{"<state_name>":{"transitions":[{},{}]}}}},"language":"JSON"},{"type":"heading","data":"Example of a state transitions"},{"type":"code","data":{"controller.animation.tiger.move":{"states":{"default":{"animations":["base_pose","walk"],"transitions":[{"angry":"query.is_angry"},{"tired":"variable.is_tired"}]},"angry":{"animations":["roar","extend_claws"],"transitions":[{"default":"query.any_animation_finished"}]},"tired":{"animations":["yawn","stretch"],"transitions":[{"default":"query.all_animation_finished"}]}}}},"language":"JSON"},{"type":"heading","data":"State Blending"},{"type":"other","data":"to the time you would like the system to take in blending between the two states.  This is done as a simple lerp between the two states over the time specified."},{"type":"heading","data":"Example of blending between two states"},{"type":"code","data":{"controller.animation.tiger.move":{"states":{"default":{"animations":["base_pose","walk"],"transitions":[{"angry":"query.is_angry"}],"blend_transition":0.2},"angry":{"animations":["roar","extend_claws"],"transitions":[{"default":"query.any_animation_finished"}]}}}},"language":"JSON"},{"type":"heading","data":"Channels (Rotation, Position, Scale)"},{"type":"other","data":"The engine tracks the animation of rotation, position, and scale separately.  Within a channel, one or more key frames are specified at arbitrary times, in seconds, from the start of the animation.  If no key frames are specified, a single key frame is created at t=0.0 and all channel data is stored within that key frame."},{"type":"heading","data":"Entity Animation Format Examples"},{"type":"other","data":"Listed below are common examples of how the Animation format is written in JSON.  Note Matching the geometry format, units are in 1/16ths of meters."},{"type":"code","data":"<animation_name>\": {\n  // optional\n  \"loop\": <bool>                                       // default = false.  Should the animation loop back to t=0.0 when it finishes?\n  \"blend_weight\": <expression>                         // default = \"1.0\".  How much this animation is blended with the others.  0.0 = off.  1.0 = fully apply all transforms.  Can be an expression - see the Animation Controller section below\n  \"animation_length\": <float>                          // default = time of last key frame.  At what time does the system consider this animation finished?\n  \"override_previous_animation\": <bool>                // default = false.  Should the animation pose of the bone be set to the bind pose before applying this animation, thereby overriding any previous animations to this point?\n\n  // required\n  \"bones\": [\n    {\n    \"<bone_name>\": {                                   // must match the name of the bone specified in the geometry skeleton\n      // various flavours of setting data\n      // omitting a channel skips that channel for this animation of this bone\n      // any number of floats below can be replaced by a string expression as described above; you don't have to replace all the floats on a line with expressions, only the ones you want to be expression-based\n      \"position\": 1.0,                                 // set x, y, and z to 1\n      \"position\": [1.0],                               // set x, y, and z to 1\n      \"position\": [1.0, 2.0, 3.0],                     // set x=1 , y=2 , and z=3\n      \"rotation\": 45.0,                                // set x, y, and z to 45 degrees\n      \"rotation\": [45.0],                              // set x, y, and z to 45 degrees\n      \"rotation\": [30.0, 0.0, 45.0],                   // set x, y, and z to the respective values (in degrees)\n      // note: only uniform scaling is supported at this time\n      \"scale\": 2.0,                                    // scales the bone by 2.0\n      \"scale\": [2.0],                                  // scales the bone by 2.0\n      // Key frame data is described below\n      // Note that any of the above styles of values will work for \"pre\" and \"post\", and \"pre\" does not have to have the same format as \"post\"\n      \"rotation\": {\n        \"0.0\": [80.0, 0.0, 0.0],\n        \"0.1667\": [-80.0, 0.0, 0.0],\n        \"0.333\": [80.0, 0.0, 0.0]\n      }\n      // For discontinuous channel curve, you can specify a different value when interpolating to/from this key frame\n      \"rotation\": {\n        \"0.3\": {                                       // the key field is the time stamp for this key frame: the value can be any of the above examples\n        \"pre\": [30.0, 0.0, 45.0],                      // when interpolating towards this key frame from the previous, use this value\n        \"post\": \"180.0 * Math.Sin(global.key_frame_lerp_time)\"  // when at interpolating away from this key frame to the next, use this value\n        }\n      }\n      // another example\n      \"rotation\": {\n        \"0.0\": [80.0, 0.0, 0.0],                       // start at an x rotation of 80 degrees\n        \"0.4\": {\n        \"pre\": [80.0, 0.0, 0.0],                       // stay at 80 until 0.4 seconds have elapsed\n        \"post\": [0.0, 0.0, 0.0],                       // discontinuously pop the x rotation to 0.0 degrees\n        },\n        \"0.8\": [-80.0, 0.0, 0.0]                       // using the previous frame's lerp mode, lerp to a x rotation of -80 degrees by 0.8 seconds\n      }\n    }\n  ]\n}","language":""}]